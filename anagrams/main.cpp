/**
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE.txt
* file distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

#include <QtCore/QCoreApplication>
#include <QHash>
#include <QStringList>

#include <QDebug>

typedef struct AnagramTreeNode {
    QHash< QString, AnagramTreeNode* > m_children;

    /*
     * Self-explanatory...
     */
    inline bool hasChild( QString aValue ) {
        return m_children.contains( aValue );
    }

    /*
     * Create a child AnagramTreeNode with containing aValue
     * If the aValue is already a child then we don't do anything: think
     * think about the anagram of the word "aaa", it's just aaa,
     * so one we have evaluated starting with a letter we don't go that route anymore.
     *
     */
    AnagramTreeNode* createChild( QString aValue ) {
        AnagramTreeNode* child = 0;
        if( !hasChild( aValue ) ) {
            if( AnagramTreeNode* node = new AnagramTreeNode() ) {
                m_children.insert( aValue, node );
                child = node;
            }
        }
        return child;
    }

} AnagramTreeNode;

/*
 * Create the anagram tree corresponding generated by aRemainingList.
 * Use root as the root node. Ordering of the anagram is not taken into account.
 */
void createTree( AnagramTreeNode* aRoot, QStringList& aRemainingList ) {
    int count = aRemainingList.count();
    // check for null pointer and whether there are still more strings/characters to consider
    if( aRoot && count > 0 ) {
        // per each character...
        for( int i = 0; i < count; ++i ) {
            // select the first, this takes constant time since QList keeps, naturally, a reference to the first item of the list
            QString aNewAttempt = aRemainingList.takeAt(0);
            // check wheter we can create a child with the corresponding value, i.e. not there already, hence the use of the QHash
            if( AnagramTreeNode* child = aRoot->createChild( aNewAttempt ) ) {
                // since we managed to create the child now we create the tree below it
                // using the reamaining strings/characters
                createTree( child, aRemainingList );
            }
            // reappend the string/character just used so it can be used once we unwind the stack.
            // the append takes constant time since QList keeps a reference to the last item of the list ;)
            aRemainingList.append( aNewAttempt );
        }
    }
}

/*
 * Create the anagram tree corresponding generated by aStringList.
 */
AnagramTreeNode* findAnagrams( QStringList aStringList ) {
    // create the tree root
    AnagramTreeNode* root = new AnagramTreeNode();

    //create the anagram tree...
    createTree( root, aStringList );

    return root;
}

/*
 * Print all the anagrams.
 * Once we reach a leaf node the correspondent anagram is the word composed
 * by the values of the nodes passed from the root to the leaf.
 * the parameter aWord works as an accumulator during our tree visit to construct
 * our anagram word step by step.
 */
void printAnagrams( AnagramTreeNode* aRoot, QStringList aWord ) {
    if( aRoot ) {
        QHash< QString, AnagramTreeNode* > children = aRoot->m_children;
        if( children.count() ) {
            foreach( QString child, children.keys() ) {
                aWord.append( child );
                printAnagrams( children.value( child ), aWord );
                aWord.removeLast();
            }
        } else {
            // who hoo! we found a leaf, ergo an anagram, let's print it!
            qDebug() << "anagram:" << aWord;
        }
    }
}

/*
 * Print all the anagrams.
 */
void printAnagrams( AnagramTreeNode* aRoot ) {
    QStringList word;
    printAnagrams( aRoot, word );
}

/*
 * Release memory.
 */
void deleteTree( AnagramTreeNode* aRoot ) {
    if( aRoot ) {
        QHash< QString, AnagramTreeNode* >& children = aRoot->m_children;
        foreach( QString child, children.keys() ) {
            deleteTree( children.value( child, 0 ) );
        }
        // delete dangling pointers...
        children.clear();
        // and the root itself!
        delete aRoot;
    }
}

int main(int argc, char *argv[])
{
    QCoreApplication a( argc, argv );

    qDebug() << "----------------------";

    QStringList noRepetitionWord;
    noRepetitionWord.append("1");
    noRepetitionWord.append("2");
    noRepetitionWord.append("3");
    noRepetitionWord.append("4");

    AnagramTreeNode* root = findAnagrams( noRepetitionWord );
    printAnagrams( root );
    deleteTree( root );

    qDebug() << "----------------------";

    QStringList doubleRepetitionWord;
    doubleRepetitionWord.append("a");
    doubleRepetitionWord.append("b");
    doubleRepetitionWord.append("b");
    doubleRepetitionWord.append("a");

    AnagramTreeNode* root2 = findAnagrams( doubleRepetitionWord );
    printAnagrams( root2 );
    deleteTree( root2 );

    qDebug() << "----------------------";

    QStringList oneAnagramOnlyWord;
    oneAnagramOnlyWord.append("a");
    oneAnagramOnlyWord.append("a");
    oneAnagramOnlyWord.append("a");
    oneAnagramOnlyWord.append("a");

    AnagramTreeNode* root3 = findAnagrams( oneAnagramOnlyWord );
    printAnagrams( root3 );
    deleteTree( root3 );

    qDebug() << "----------------------";

    return 0;
}



